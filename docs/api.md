# Публичный API движка

## EngineConfig

`EngineConfig` — входная конфигурация при создании движка.

| Поле | Тип | Описание |
| --- | --- | --- |
| `seed` | `number` | Сид для детерминированного RNG. |
| `players` | `PlayerId[]` | Список идентификаторов игроков в порядке ходов. Должен быть непустым. |
| `zones` | `string[]` | Список зон, которые будут созданы для каждого игрока. По умолчанию: `hand`, `deck`, `discard`, `exile`, `field`. |
| `rules` | `RuleModule[]` | Список модулей правил, регистрируемых при создании движка. По умолчанию: пустой массив. |
| `plugins` | `EnginePlugin[]` | Список плагинов, подключаемых после регистрации правил. По умолчанию: пустой массив. |
| `maxEventChain` | `number` | Лимит глубины цепочки событий и лимит разрешения отложенных действий. По умолчанию: `1024`. |

## normalizeEngineConfig

`normalizeEngineConfig(config)` возвращает нормализованную конфигурацию с заполненными
значениями по умолчанию (`zones`, `rules`, `plugins`, `maxEventChain`). Функция также валидирует базовые
условия, например наличие хотя бы одного игрока.

### NormalizedEngineConfig

Результат нормализации всегда содержит полные списки:

| Поле | Тип | Описание |
| --- | --- | --- |
| `zones` | `string[]` | Зоны с учётом дефолтов. |
| `rules` | `RuleModule[]` | Модули правил (может быть пустым массивом). |
| `plugins` | `EnginePlugin[]` | Плагины (может быть пустым массивом). |
| `maxEventChain` | `number` | Эффективный лимит глубины цепочки событий и разрешения отложенных действий. |

## Контракты RuleModule и EnginePlugin

```ts
export interface RuleModule {
  name: string;
  register: (engine: GameEngine) => void;
}

export interface EnginePlugin {
  name: string;
  onRegister?: (engine: GameEngine) => void;
}
```

- `RuleModule.register(...)` вызывается всегда и служит для регистрации правил, обработчиков событий и эффектов.
- `EnginePlugin.onRegister(...)` опционален и вызывается при подключении плагина.

### Порядок регистрации

При вызове `GameEngine.create(...)` сначала регистрируются все правила из `config.rules`, затем подключаются плагины из `config.plugins`. Это позволяет плагинам опираться на уже зарегистрированные правила.

## Планировщик отложенных действий

Для расширенных правил доступен встроенный deterministic-планировщик:

```ts
export interface ScheduleActionInput {
  id: string;
  priority?: number;
  delayTurns?: number;
  phase?: Phase;
  run: (context: GameContext) => void;
}
```

### `engine.scheduleAction(input)`

Регистрирует отложенное действие. Порядок разрешения всегда детерминирован:
1. Ход (`delayTurns` + текущий ход).
2. Фаза (`phase`, либо текущая фаза, если поле пропущено).
3. Приоритет (`priority`, по убыванию).
4. Порядок регистрации.
5. `id` (лексикографически, как последний tie-breaker).

### `engine.flushScheduledActions()`

Принудительно пытается разрешить все готовые действия для текущих хода/фазы. Обычно
вызывать вручную не нужно: движок делает это автоматически после `phaseStart` в
`startTurn`, `nextPhase` и `endTurn`.

### `engine.getScheduledActionsCount()`

Возвращает текущее число ожидающих отложенных действий.

### Защита от бесконечного самопланирования

Если во время `flushScheduledActions()` правила бесконечно планируют новые «готовые сейчас»
действия, движок прерывает цикл по `maxEventChain` и выбрасывает ошибку.

## Защита от бесконечных цепочек событий

Метод `emitEvent(...)` отслеживает глубину вложенных вызовов событий. Если глубина
превышает `maxEventChain`, движок выбрасывает ошибку и прерывает обработку.
Это защищает ядро от неконтролируемой рекурсии в правилах и плагинах.
